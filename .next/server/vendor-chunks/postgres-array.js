"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/postgres-array";
exports.ids = ["vendor-chunks/postgres-array"];
exports.modules = {

/***/ "(rsc)/./node_modules/postgres-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/postgres-array/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nconst BACKSLASH = '\\\\'\nconst DQUOT = '\"'\nconst LBRACE = '{'\nconst RBRACE = '}'\nconst LBRACKET = '['\nconst EQUALS = '='\nconst COMMA = ','\n\n/** When the raw value is this, it means a literal `null` */\nconst NULL_STRING = 'NULL'\n\n/**\n * Parses an array according to\n * https://www.postgresql.org/docs/17/arrays.html#ARRAYS-IO\n *\n * Trusts the data (mostly), so only hook up to trusted Postgres servers.\n */\nfunction makeParseArrayWithTransform (transform) {\n  const haveTransform = transform != null\n  return function parseArray (str) {\n    const rbraceIndex = str.length - 1\n    if (rbraceIndex === 1) {\n      return []\n    }\n    if (str[rbraceIndex] !== RBRACE) {\n      throw new Error('Invalid array text - must end with }')\n    }\n\n    // If starts with `[`, it is specifying the index boundas. Skip past first `=`.\n    let position = 0\n    if (str[position] === LBRACKET) {\n      position = str.indexOf(EQUALS) + 1\n    }\n\n    if (str[position++] !== LBRACE) {\n      throw new Error('Invalid array text - must start with {')\n    }\n    const output = []\n    let current = output\n    const stack = []\n\n    let currentStringStart = position\n    let currentString = ''\n    let expectValue = true\n\n    for (; position < rbraceIndex; ++position) {\n      let char = str[position]\n      // > The array output routine will put double quotes around element values if\n      // > they are empty strings, contain curly braces, delimiter characters, double\n      // > quotes, backslashes, or white space, or match the word NULL. Double quotes\n      // > and backslashes embedded in element values will be backslash-escaped.\n      if (char === DQUOT) {\n        // It's escaped\n        currentStringStart = ++position\n        let dquot = str.indexOf(DQUOT, currentStringStart)\n        let backSlash = str.indexOf(BACKSLASH, currentStringStart)\n        while (backSlash !== -1 && backSlash < dquot) {\n          position = backSlash\n          const part = str.slice(currentStringStart, position)\n          currentString += part\n          currentStringStart = ++position\n          if (dquot === position++) {\n            // This was an escaped doublequote; find the next one!\n            dquot = str.indexOf(DQUOT, position)\n          }\n          // Either way, find the next backslash\n          backSlash = str.indexOf(BACKSLASH, position)\n        }\n        position = dquot\n        const part = str.slice(currentStringStart, position)\n        currentString += part\n        current.push(haveTransform ? transform(currentString) : currentString)\n        currentString = ''\n        expectValue = false\n      } else if (char === LBRACE) {\n        const newArray = []\n        current.push(newArray)\n        stack.push(current)\n        current = newArray\n        currentStringStart = position + 1\n        expectValue = true\n      } else if (char === COMMA) {\n        expectValue = true\n      } else if (char === RBRACE) {\n        expectValue = false\n        const arr = stack.pop()\n        if (arr === undefined) {\n          throw new Error(\"Invalid array text - too many '}'\")\n        }\n        current = arr\n      } else if (expectValue) {\n        currentStringStart = position\n        while (\n          (char = str[position]) !== COMMA &&\n          char !== RBRACE &&\n          position < rbraceIndex\n        ) {\n          ++position\n        }\n        const part = str.slice(currentStringStart, position--)\n        current.push(\n          part === NULL_STRING ? null : haveTransform ? transform(part) : part\n        )\n        expectValue = false\n      } else {\n        throw new Error('Was expecting delimeter')\n      }\n    }\n\n    return output\n  }\n}\n\nconst parseArray = makeParseArrayWithTransform()\n\nexports.parse = (source, transform) =>\n  transform != null\n    ? makeParseArrayWithTransform(transform)(source)\n    : parseArray(source)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG9zdGdyZXMtYXJyYXkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8yNDctZmJhLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3Bvc3RncmVzLWFycmF5L2luZGV4LmpzP2NjNDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJBQ0tTTEFTSCA9ICdcXFxcJ1xuY29uc3QgRFFVT1QgPSAnXCInXG5jb25zdCBMQlJBQ0UgPSAneydcbmNvbnN0IFJCUkFDRSA9ICd9J1xuY29uc3QgTEJSQUNLRVQgPSAnWydcbmNvbnN0IEVRVUFMUyA9ICc9J1xuY29uc3QgQ09NTUEgPSAnLCdcblxuLyoqIFdoZW4gdGhlIHJhdyB2YWx1ZSBpcyB0aGlzLCBpdCBtZWFucyBhIGxpdGVyYWwgYG51bGxgICovXG5jb25zdCBOVUxMX1NUUklORyA9ICdOVUxMJ1xuXG4vKipcbiAqIFBhcnNlcyBhbiBhcnJheSBhY2NvcmRpbmcgdG9cbiAqIGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvMTcvYXJyYXlzLmh0bWwjQVJSQVlTLUlPXG4gKlxuICogVHJ1c3RzIHRoZSBkYXRhIChtb3N0bHkpLCBzbyBvbmx5IGhvb2sgdXAgdG8gdHJ1c3RlZCBQb3N0Z3JlcyBzZXJ2ZXJzLlxuICovXG5mdW5jdGlvbiBtYWtlUGFyc2VBcnJheVdpdGhUcmFuc2Zvcm0gKHRyYW5zZm9ybSkge1xuICBjb25zdCBoYXZlVHJhbnNmb3JtID0gdHJhbnNmb3JtICE9IG51bGxcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlQXJyYXkgKHN0cikge1xuICAgIGNvbnN0IHJicmFjZUluZGV4ID0gc3RyLmxlbmd0aCAtIDFcbiAgICBpZiAocmJyYWNlSW5kZXggPT09IDEpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBpZiAoc3RyW3JicmFjZUluZGV4XSAhPT0gUkJSQUNFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJyYXkgdGV4dCAtIG11c3QgZW5kIHdpdGggfScpXG4gICAgfVxuXG4gICAgLy8gSWYgc3RhcnRzIHdpdGggYFtgLCBpdCBpcyBzcGVjaWZ5aW5nIHRoZSBpbmRleCBib3VuZGFzLiBTa2lwIHBhc3QgZmlyc3QgYD1gLlxuICAgIGxldCBwb3NpdGlvbiA9IDBcbiAgICBpZiAoc3RyW3Bvc2l0aW9uXSA9PT0gTEJSQUNLRVQpIHtcbiAgICAgIHBvc2l0aW9uID0gc3RyLmluZGV4T2YoRVFVQUxTKSArIDFcbiAgICB9XG5cbiAgICBpZiAoc3RyW3Bvc2l0aW9uKytdICE9PSBMQlJBQ0UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcnJheSB0ZXh0IC0gbXVzdCBzdGFydCB3aXRoIHsnKVxuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBbXVxuICAgIGxldCBjdXJyZW50ID0gb3V0cHV0XG4gICAgY29uc3Qgc3RhY2sgPSBbXVxuXG4gICAgbGV0IGN1cnJlbnRTdHJpbmdTdGFydCA9IHBvc2l0aW9uXG4gICAgbGV0IGN1cnJlbnRTdHJpbmcgPSAnJ1xuICAgIGxldCBleHBlY3RWYWx1ZSA9IHRydWVcblxuICAgIGZvciAoOyBwb3NpdGlvbiA8IHJicmFjZUluZGV4OyArK3Bvc2l0aW9uKSB7XG4gICAgICBsZXQgY2hhciA9IHN0cltwb3NpdGlvbl1cbiAgICAgIC8vID4gVGhlIGFycmF5IG91dHB1dCByb3V0aW5lIHdpbGwgcHV0IGRvdWJsZSBxdW90ZXMgYXJvdW5kIGVsZW1lbnQgdmFsdWVzIGlmXG4gICAgICAvLyA+IHRoZXkgYXJlIGVtcHR5IHN0cmluZ3MsIGNvbnRhaW4gY3VybHkgYnJhY2VzLCBkZWxpbWl0ZXIgY2hhcmFjdGVycywgZG91YmxlXG4gICAgICAvLyA+IHF1b3RlcywgYmFja3NsYXNoZXMsIG9yIHdoaXRlIHNwYWNlLCBvciBtYXRjaCB0aGUgd29yZCBOVUxMLiBEb3VibGUgcXVvdGVzXG4gICAgICAvLyA+IGFuZCBiYWNrc2xhc2hlcyBlbWJlZGRlZCBpbiBlbGVtZW50IHZhbHVlcyB3aWxsIGJlIGJhY2tzbGFzaC1lc2NhcGVkLlxuICAgICAgaWYgKGNoYXIgPT09IERRVU9UKSB7XG4gICAgICAgIC8vIEl0J3MgZXNjYXBlZFxuICAgICAgICBjdXJyZW50U3RyaW5nU3RhcnQgPSArK3Bvc2l0aW9uXG4gICAgICAgIGxldCBkcXVvdCA9IHN0ci5pbmRleE9mKERRVU9ULCBjdXJyZW50U3RyaW5nU3RhcnQpXG4gICAgICAgIGxldCBiYWNrU2xhc2ggPSBzdHIuaW5kZXhPZihCQUNLU0xBU0gsIGN1cnJlbnRTdHJpbmdTdGFydClcbiAgICAgICAgd2hpbGUgKGJhY2tTbGFzaCAhPT0gLTEgJiYgYmFja1NsYXNoIDwgZHF1b3QpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IGJhY2tTbGFzaFxuICAgICAgICAgIGNvbnN0IHBhcnQgPSBzdHIuc2xpY2UoY3VycmVudFN0cmluZ1N0YXJ0LCBwb3NpdGlvbilcbiAgICAgICAgICBjdXJyZW50U3RyaW5nICs9IHBhcnRcbiAgICAgICAgICBjdXJyZW50U3RyaW5nU3RhcnQgPSArK3Bvc2l0aW9uXG4gICAgICAgICAgaWYgKGRxdW90ID09PSBwb3NpdGlvbisrKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdhcyBhbiBlc2NhcGVkIGRvdWJsZXF1b3RlOyBmaW5kIHRoZSBuZXh0IG9uZSFcbiAgICAgICAgICAgIGRxdW90ID0gc3RyLmluZGV4T2YoRFFVT1QsIHBvc2l0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFaXRoZXIgd2F5LCBmaW5kIHRoZSBuZXh0IGJhY2tzbGFzaFxuICAgICAgICAgIGJhY2tTbGFzaCA9IHN0ci5pbmRleE9mKEJBQ0tTTEFTSCwgcG9zaXRpb24pXG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24gPSBkcXVvdFxuICAgICAgICBjb25zdCBwYXJ0ID0gc3RyLnNsaWNlKGN1cnJlbnRTdHJpbmdTdGFydCwgcG9zaXRpb24pXG4gICAgICAgIGN1cnJlbnRTdHJpbmcgKz0gcGFydFxuICAgICAgICBjdXJyZW50LnB1c2goaGF2ZVRyYW5zZm9ybSA/IHRyYW5zZm9ybShjdXJyZW50U3RyaW5nKSA6IGN1cnJlbnRTdHJpbmcpXG4gICAgICAgIGN1cnJlbnRTdHJpbmcgPSAnJ1xuICAgICAgICBleHBlY3RWYWx1ZSA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IExCUkFDRSkge1xuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdXG4gICAgICAgIGN1cnJlbnQucHVzaChuZXdBcnJheSlcbiAgICAgICAgc3RhY2sucHVzaChjdXJyZW50KVxuICAgICAgICBjdXJyZW50ID0gbmV3QXJyYXlcbiAgICAgICAgY3VycmVudFN0cmluZ1N0YXJ0ID0gcG9zaXRpb24gKyAxXG4gICAgICAgIGV4cGVjdFZhbHVlID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBDT01NQSkge1xuICAgICAgICBleHBlY3RWYWx1ZSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gUkJSQUNFKSB7XG4gICAgICAgIGV4cGVjdFZhbHVlID0gZmFsc2VcbiAgICAgICAgY29uc3QgYXJyID0gc3RhY2sucG9wKClcbiAgICAgICAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcnJheSB0ZXh0IC0gdG9vIG1hbnkgJ30nXCIpXG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGFyclxuICAgICAgfSBlbHNlIGlmIChleHBlY3RWYWx1ZSkge1xuICAgICAgICBjdXJyZW50U3RyaW5nU3RhcnQgPSBwb3NpdGlvblxuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgKGNoYXIgPSBzdHJbcG9zaXRpb25dKSAhPT0gQ09NTUEgJiZcbiAgICAgICAgICBjaGFyICE9PSBSQlJBQ0UgJiZcbiAgICAgICAgICBwb3NpdGlvbiA8IHJicmFjZUluZGV4XG4gICAgICAgICkge1xuICAgICAgICAgICsrcG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0ID0gc3RyLnNsaWNlKGN1cnJlbnRTdHJpbmdTdGFydCwgcG9zaXRpb24tLSlcbiAgICAgICAgY3VycmVudC5wdXNoKFxuICAgICAgICAgIHBhcnQgPT09IE5VTExfU1RSSU5HID8gbnVsbCA6IGhhdmVUcmFuc2Zvcm0gPyB0cmFuc2Zvcm0ocGFydCkgOiBwYXJ0XG4gICAgICAgIClcbiAgICAgICAgZXhwZWN0VmFsdWUgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYXMgZXhwZWN0aW5nIGRlbGltZXRlcicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dFxuICB9XG59XG5cbmNvbnN0IHBhcnNlQXJyYXkgPSBtYWtlUGFyc2VBcnJheVdpdGhUcmFuc2Zvcm0oKVxuXG5leHBvcnRzLnBhcnNlID0gKHNvdXJjZSwgdHJhbnNmb3JtKSA9PlxuICB0cmFuc2Zvcm0gIT0gbnVsbFxuICAgID8gbWFrZVBhcnNlQXJyYXlXaXRoVHJhbnNmb3JtKHRyYW5zZm9ybSkoc291cmNlKVxuICAgIDogcGFyc2VBcnJheShzb3VyY2UpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/postgres-array/index.js\n");

/***/ })

};
;